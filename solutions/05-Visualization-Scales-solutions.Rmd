---
title: "R Notebook"
output: html_document
---

```{r setup}
library(tidyverse)
library(geoscidata)
```

## warwick

```{r}
warwick
```

## Your Turn 1

Look through the columns of `warwick`. Which columns are __discrete__ variables, and which columns are __continuous__ variables?

- Continuous: `longitude`, `latitude`, `date_sampled`, `magnetics`, `*_ppm`
- Discrete: `station_id`, `sample_id`, `type`, `rock_type`, `rock_name`, `rock_group`, `rock_age`, `rock_gcode`, `rock_desc`, `legend`, `geologist`, `quality`

## Your Turn 2

Identify the 4 scales on this plot, the variable and aesthetic associated with each, and whether each are continuous or discrete.

```{r}
ggplot(warwick) + 
  geom_jitter(aes(x = rock_name, y = Mn_ppm, color = K_ppm, shape = rock_type))
```

## Your Turn 3

Set the __breaks__ of the Y scale to include multiples of 500 from 0 to 4500 (hint: you will have to create a vector of values using `c()` or `seq()`. For bonus marks, set the __breaks__ of the X scale to multiples of 125,000.

```{r}
ggplot(warwick) + 
  geom_point(aes(x = Fe_ppm, y = Mn_ppm, color = rock_name)) +
  scale_y_continuous(breaks = c(0, 500, 1000, 1500, 2000, 2500, 3000, 3500, 4000, 4500)) +
  scale_x_continuous(breaks = c(0, 125000, 250000, 375000, 500000, 625000, 750000, 875000))
```

You can also set the `minor_breaks` argument to `scale_*_continuous()` functions to set the locations of the minor breaks.

## Your Turn 4

The __labels__ argument to `scale_*` functions takes a function that turns the __breaks__ into human-readable text. The _scales_ package provides functions that generate labeller functions that work in this context. 

Use the __labels__ argument of `scale_x_continuous()` and `scale_y_continuous()`, and the `scales::number_format()` function generator to turn the breaks for the X and Y axis into human-readable values on the final plot.

```{r}
ggplot(warwick) + 
  geom_point(aes(x = Fe_ppm, y = Mn_ppm, color = rock_name)) +
  scale_x_continuous(labels = scales::number_format()) +
  scale_y_continuous(labels = scales::number_format())
```

Other useful labellers are `scales::dollar_format()`, `scales::scientific_format()` (among others in the _scales_ package).

## Your Turn 5

Change the X and Y scales to log base 10 scales using the `scale_*_log10()` functions.

```{r}
ggplot(warwick) + 
  geom_point(aes(x = Fe_ppm, y = Mn_ppm, color = rock_name)) +
  scale_x_log10() +
  scale_y_log10()
```

## Your Turn 6

Order the limits in the colour scale in the order of most samples to least samples (volcanic, intrusive, sedimentary, hydrothermal).

```{r}
ggplot(warwick) + 
  geom_boxplot(aes(x = rock_name, y = Mn_ppm, color = rock_type)) +
  scale_color_discrete(
    limits = c("volcanic", "intrusive", "sedimentary", "hydrothermal")
  )
```

## Your Turn 7

Order the breaks in the X axis scale so that rock types are listed next to eachother. 

```{r}
ggplot(warwick) + 
  geom_boxplot(aes(x = rock_name, y = Mn_ppm, color = rock_type)) +
  scale_x_discrete(
    limits = c("basalt", "breccia", "rhyolite", "tuff", 
               "conglomerate", "limestone", "sandstone", "siltstone",
               "diorite", "porphyry",
               "vein")
  )
```

## Your Turn 8

Use [colorbrewer2.org](http://colorbrewer2.org) and the `palette` argument of `scale_color_brewer()` to choose a prettier discrete colour scale for the `color` aesthetic.

```{r}
ggplot(warwick) + 
  geom_boxplot(aes(x = rock_name, y = Mn_ppm, color = rock_type)) +
  scale_color_brewer(palette = "Set2")
```

## Your Turn 9

Make a scatterplot of the `warwick` dataset (`K_ppm`, `Rb_ppm`) as pretty as you possibly can using the techniques you just learned. The plot should have:

- Log scales for the X and Y axis
- Break labels that have nicely human-readable numbers
- Scale labels that have nicely human-readable values
- An `alpha` value of 0.3 for each point to a number to reduce the effect of overplotting

```{r}
ggplot(warwick) + 
  geom_point(aes(x = K_ppm, y = Rb_ppm, col = rock_name), alpha = 0.3) +
  scale_x_log10(labels = scales::comma_format()) +
  scale_y_log10(labels = scales::comma_format()) +
  labs(x = "K (ppm)", y = "Rb (ppm)", col = "Rock Type")
```

***

# Take Aways

- Columns in a table are always interpreted as continuous or discrete by ggplot2. The `factor()` function can be used to convert a contiuous variable to a discrete one.
- The default scales that are created when R can be modified by adding a customized scale created by `scale_<AESTHETIC>_*()` functions.
- Continuous scale functions have a `breaks` argument that controls where labeled breaks occur on the plot. The value should be a vector, usually created using `c()` or `seq()`. The `label` argument can be set to `scales::*_format(<ARGS>)` to make break values human-readable.
- Discrete scale functions have a `limits` argument that controls the order that values should appear along the scale. The value should be a character vector, usually created with `c()`.

# More Practice

- The [Graphics for Communication (scales)](https://r4ds.had.co.nz/graphics-for-communication.html#scales) chapter of [R for Data Science](https://r4ds.had.co.nz/).
- The [Plot Customization Primer](https://rstudio.cloud/learn/primers/3.8) from [RStudio Cloud](https://rstudio.cloud/)
