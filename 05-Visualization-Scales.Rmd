---
title: "Scales in ggplot2"
output: html_notebook
---

```{r setup}
library(tidyverse)
library(geoscidata)
```

## warwick

```{r}
warwick
```

## Your Turn 1

Look through the columns of `warwick`. Which columns are __discrete__ variables, and which columns are __continuous__ variables?

- Continuous variables: 
- Discrete variables: 

## Your Turn 2

What is the difference between these two plots:

```{r}
warwick %>%
  filter(!is.na(date_sampled)) %>%
  ggplot() + 
  geom_bar(aes(x = date_sampled)) +
  coord_flip()
```

```{r}
warwick %>%
  filter(!is.na(date_sampled)) %>%
  ggplot() + 
  geom_bar(aes(x = factor(date_sampled))) +
  coord_flip()
```

## Your Turn 3

Identify the 4 scales on this plot, the variable and aesthetic associated with each, and whether each are continuous or discrete.

```{r}
ggplot(warwick) + 
  geom_jitter(aes(x = rock_name, y = Mn_ppm, color = K_ppm, shape = rock_type))
```

## Your Turn 4

Set the __breaks__ of the Y scale to include multiples of 500 from 0 to 4500 (hint: you will have to create a vector of values using `c()` or `seq()`. For bonus marks, set the __breaks__ of the X scale to multiples of 125,000.

```{r}
ggplot(warwick) + 
  geom_point(aes(x = Fe_ppm, y = Mn_ppm, color = rock_name))
```

You can also set the `minor_breaks` argument to `scale_*_continuous()` functions to set the locations of the minor breaks.

## Your Turn 5

The __labels__ argument to `scale_*` functions takes a function that turns the __breaks__ into human-readable text. The _scales_ package provides functions that generate labeller functions that work in this context. 

Use the __labels__ argument of `scale_x_continuous()` and `scale_y_continuous()`, and the `scales::number_format()` function generator to turn the breaks for the X and Y axis into human-readable values on the final plot.

```{r}
ggplot(warwick) + 
  geom_point(aes(x = Fe_ppm, y = Mn_ppm, color = rock_name))
```

Other useful labellers are `scales::dollar_format()`, `scales::scientific_format()` (among others in the _scales_ package).

## Your Turn 6

Change the X and Y scales to log base 10 scales using the `scale_*_log10()` functions.

```{r}
ggplot(warwick) + 
  geom_point(aes(x = Fe_ppm, y = Mn_ppm, color = rock_name))
```

## Your Turn 7

Order the limits in `scale_x_discrete()` in the order of most samples to least samples (volcanic, intrusive, sedimentary, hydrothermal).

```{r}
ggplot(warwick) + 
  geom_boxplot(aes(x = rock_name, y = Mn_ppm, color = rock_type))
```

## Your Turn 8

Order the breaks in the X axis scale so that rock types (bars with the same color) are listed next to eachother. 

```{r}
ggplot(warwick) + 
  geom_boxplot(aes(x = rock_name, y = Mn_ppm, color = rock_type)) +
  scale_x_discrete(limits = ______)
```

## Your Turn 9

Use [colorbrewer2.org](http://colorbrewer2.org) and the `palette` argument of `scale_color_brewer()` to choose a prettier discrete colour scale for the `color` aesthetic.

```{r}
ggplot(warwick) + 
  geom_boxplot(aes(x = rock_name, y = Mn_ppm, color = rock_type)) +
  scale_color_brewer(______ = ____________)
```

## Exam

Make a scatterplot of the `warwick` dataset (`K_ppm`, `Rb_ppm`) as pretty as you possibly can using the techniques you just learned. The plot should have:

- Log scales for the X and Y axis
- Break labels that have nicely human-readable numbers
- Axis/scale labels that have nicely human-readable values
- An `alpha` value of 0.3 for each point to a number to reduce the effect of overplotting

```{r}
ggplot(warwick) + 
  geom_point(aes(x = K_ppm, y = Rb_ppm, col = rock_name))
```

***

# Take Aways

- Columns in a table are always interpreted as continuous or discrete by ggplot2. The `factor()` function can be used to convert a contiuous variable to a discrete one.
- The default scales that are created when R can be modified by adding a customized scale created by `scale_<AESTHETIC>_*()` functions.
- Continuous scale functions have a `breaks` argument that controls where labeled breaks occur on the plot. The value should be a vector, usually created using `c()` or `seq()`. The `label` argument can be set to `scales::*_format(<ARGS>)` to make break values human-readable.
- Discrete scale functions have a `limits` argument that controls the order that values should appear along the scale. The value should be a character vector, usually created with `c()`.

# More Practice

- The [Graphics for Communication (scales)](https://r4ds.had.co.nz/graphics-for-communication.html#scales) chapter of [R for Data Science](https://r4ds.had.co.nz/).
- The [Plot Customization Primer](https://rstudio.cloud/learn/primers/3.8) from [RStudio Cloud](https://rstudio.cloud/)
